---
interface Props {
    nodeCount?: number;
    connectDistance?: number;
    nodeSpeed?: number;
    returnSpeed?: number;
    pointerRadius?: number;
    repulsionForce?: number;
}

const {
    nodeCount = 100,
    connectDistance = 120,
    nodeSpeed = 0.3,
    returnSpeed = 0.02,
    pointerRadius = 80,
    repulsionForce = 0.2
} = Astro.props;
---

<canvas id="nodes" class="nodes-canvas"></canvas>

<style>
    .nodes-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: auto;

        background: var(--bg-color);
    }
</style>

<script define:vars={{nodeCount, connectDistance, nodeSpeed, returnSpeed, pointerRadius, repulsionForce}}>
    let currentBackground = null;

    function initNodes() {
        const CONNECT_DISTANCE_SQ = connectDistance * connectDistance;

        const mouse = {
            x: null, y: null, isActive: false
        };

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            contains(point) {
                return (point.x >= this.x - this.w && point.x <= this.x + this.w && point.y >= this.y - this.h && point.y <= this.y + this.h);
            }

            intersects(range) {
                return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h);
            }

            set(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
        }

        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.points = [];
                this.divided = false;
                this.northeast = null;
                this.northwest = null;
                this.southeast = null;
                this.southwest = null;
            }

            clear() {
                this.points.length = 0;
                this.divided = false;
                if (this.northeast) {
                    this.northeast.clear();
                    this.northwest.clear();
                    this.southeast.clear();
                    this.southwest.clear();
                }
            }

            insert(point) {
                if (!this.boundary.contains(point)) return false;

                if (this.points.length < this.capacity) {
                    this.points.push(point);
                    return true;
                }

                if (!this.divided) {
                    this.subdivide();
                }

                return (this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point));
            }

            subdivide() {
                const x = this.boundary.x;
                const y = this.boundary.y;
                const w = this.boundary.w / 2;
                const h = this.boundary.h / 2;

                if (!this.northeast) {
                    this.northeast = new QuadTree(new Rectangle(x + w, y - h, w, h), this.capacity);
                    this.northwest = new QuadTree(new Rectangle(x - w, y - h, w, h), this.capacity);
                    this.southeast = new QuadTree(new Rectangle(x + w, y + h, w, h), this.capacity);
                    this.southwest = new QuadTree(new Rectangle(x - w, y + h, w, h), this.capacity);
                } else {
                    this.northeast.boundary.set(x + w, y - h, w, h);
                    this.northwest.boundary.set(x - w, y - h, w, h);
                    this.southeast.boundary.set(x + w, y + h, w, h);
                    this.southwest.boundary.set(x - w, y + h, w, h);
                }

                this.divided = true;
            }

            query(range, found) {
                if (!found) found = [];
                if (!this.boundary.intersects(range)) return found;

                for (let i = 0; i < this.points.length; i++) {
                    if (range.contains(this.points[i])) {
                        found.push(this.points[i]);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }
                return found;
            }
        }

        class Node {
            constructor(canvas, x, y, color, id) {
                this.canvas = canvas;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * nodeSpeed;
                this.vy = (Math.random() - 0.5) * nodeSpeed;
                this.baseVx = this.vx;
                this.baseVy = this.vy;
                this.color = color;
                this.radius = Math.random() * 3 + 3;
                this.id = id;
            }

            update() {
                if (mouse.isActive) {
                    const dx = this.x - mouse.x;
                    const dy = this.y - mouse.y;
                    const distSq = dx * dx + dy * dy;
                    const pointerRadiusSq = pointerRadius * pointerRadius;

                    if (distSq < pointerRadiusSq && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const force = (1 - dist / pointerRadius) * repulsionForce;

                        const nx = dx / dist;
                        const ny = dy / dist;

                        this.vx += nx * force;
                        this.vy += ny * force;
                    } else {
                        this.vx += (this.baseVx - this.vx) * returnSpeed;
                        this.vy += (this.baseVy - this.vy) * returnSpeed;
                    }
                } else { // Needed for when the mouse leaves the canvas or stops moving
                    this.vx += (this.baseVx - this.vx) * returnSpeed;
                    this.vy += (this.baseVy - this.vy) * returnSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > this.canvas.width) {
                    this.vx *= -1;
                    this.baseVx *= -1;
                    this.x = this.x < 0 ? 0 : this.canvas.width;
                }
                if (this.y < 0 || this.y > this.canvas.height) {
                    this.vy *= -1;
                    this.baseVy *= -1;
                    this.y = this.y < 0 ? 0 : this.canvas.height;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Connection {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', {
                    alpha: false, desynchronized: true
                });
                this.nodes = [];
                this.animationId = null;
                this.observer = null;
                this.isVisible = true;
                this.queryResults = [];
                this.searchRange = new Rectangle(0, 0, connectDistance, connectDistance);

                const boundary = new Rectangle(0, 0, 0, 0);
                this.qTree = new QuadTree(boundary, 4);

                const styles = getComputedStyle(document.documentElement);
                this.nodeColor = styles.getPropertyValue('--deep-green').trim() || '#22c55e';

                this.lastTime = performance.now();
                this.targetFPS = 60;
                this.frameInterval = 1000 / this.targetFPS;

                this.init();
            }

            init() {
                this.resize();
                this.createNodes();
                this.setupMouseHandlers();
                this.setupResizeHandler();
                this.setupVisibilityObserver();
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();

                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;

                this.ctx.scale(dpr, dpr);

                this.width = rect.width;
                this.height = rect.height;

                this.qTree.boundary.set(this.width / 2, this.height / 2, this.width / 2, this.height / 2);
            }

            createNodes() {
                this.nodes = [];
                this.nodes.length = nodeCount;

                for (let i = 0; i < nodeCount; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    this.nodes[i] = new Node({width: this.width, height: this.height}, x, y, this.nodeColor, i);
                }
            }

            drawConnections() {
                this.ctx.lineWidth = 1;

                for (let i = 0; i < this.nodes.length; i++) {
                    const node = this.nodes[i];

                    this.searchRange.x = node.x;
                    this.searchRange.y = node.y;

                    this.queryResults.length = 0;
                    this.qTree.query(this.searchRange, this.queryResults);

                    for (let j = 0; j < this.queryResults.length; j++) {
                        const other = this.queryResults[j];

                        if (node.id >= other.id) continue;

                        const dx = node.x - other.x;
                        const dy = node.y - other.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < CONNECT_DISTANCE_SQ) {
                            const distance = Math.sqrt(distSq);
                            const opacity = 1 - distance / connectDistance;

                            this.ctx.beginPath();
                            this.ctx.strokeStyle = `rgba(156, 163, 175, ${opacity})`;
                            this.ctx.moveTo(node.x, node.y);
                            this.ctx.lineTo(other.x, other.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }

            animate(currentTime) {
                if (!this.isVisible) return;

                const elapsed = currentTime - this.lastTime;

                if (elapsed < this.frameInterval) {
                    this.animationId = requestAnimationFrame(this.animate.bind(this));
                    return;
                }

                this.lastTime = currentTime - (elapsed % this.frameInterval);

                this.ctx.clearRect(0, 0, this.width, this.height);
                this.qTree.clear();

                for (let i = 0; i < this.nodes.length; i++) {
                    const node = this.nodes[i];
                    node.update();
                    node.draw(this.ctx);
                    this.qTree.insert(node);
                }

                this.drawConnections();
                this.animationId = requestAnimationFrame(this.animate.bind(this));
            }

            start() {
                if (!this.animationId && this.isVisible) {
                    this.lastTime = performance.now();
                    this.animate(this.lastTime);
                }
            }

            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            setupVisibilityObserver() {
                const options = {threshold: 0};
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        this.isVisible = entry.isIntersecting;
                        if (entry.isIntersecting) {
                            this.start();
                        } else {
                            this.stop();
                        }
                    });
                }, options);
                this.observer.observe(this.canvas);

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.isVisible = false;
                        this.stop();
                    } else {
                        this.isVisible = true;
                        this.start();
                    }
                });
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.resize();
                        for (let i = 0; i < this.nodes.length; i++) {
                            this.nodes[i].canvas.width = this.width;
                            this.nodes[i].canvas.height = this.height;
                        }
                    }, 150);
                });
            }

            destroy() {
                this.stop();
                if (this.observer) this.observer.disconnect();
            }

            setupMouseHandlers() {
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    return;
                }

                let mouseTimeout;

                window.addEventListener('mousemove', (event) => {
                    const rect = this.canvas.getBoundingClientRect();
                    mouse.x = event.clientX - rect.left;
                    mouse.y = event.clientY - rect.top;
                    mouse.isActive = true;

                    clearTimeout(mouseTimeout);
                    mouseTimeout = setTimeout(() => {
                        mouse.isActive = false;
                    }, 100);
                });

                document.addEventListener('mouseleave', () => {
                    mouse.isActive = false;
                    clearTimeout(mouseTimeout);
                });
            }
        }

        const canvas = document.getElementById('nodes');
        if (canvas) {
            if (currentBackground) {
                currentBackground.destroy();
            }

            currentBackground = new Connection(canvas);
        }
    }

    document.addEventListener('astro:page-load', initNodes);

    document.addEventListener('astro:before-preparation', () => {
        if (currentBackground) {
            currentBackground.destroy();
            currentBackground = null;
        }
    });
</script>